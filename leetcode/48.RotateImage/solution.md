### 48. Rotate Image

将矩阵顺时针旋转90°，首先考虑几种旋转的办法
* 首先考虑一种简单的，我们可以在每次中循环以边为单位处理，这就需要利用一个长度为n的中间数组保存这一条边上的数
* 另外一种我们在一次循环中以一个元素为单位，这样我们的循环中要处理四个值

第一种方法较简单，但是需要额外的数组，且数组的赋值较耗时，所以选第二种，第二种的难点在于如何确定四个位置的坐标，我们需要画个图来找规律

假设这是一次的循环，要处理这4个位置的数，首先假设位置1的坐标为（i，j）
```
    1
  * * * *
  * * * * 2
4 * * * *
  * * * *
      3
```

首先确定位置2的坐标，我们可以画图找找规律，2的横坐标是跟着j走的，纵坐标和i有关，因为i代表当前处理的那一层，所以随着层数增加，位置2的纵坐标是越来越向左移动的，所以位置2的坐标是（j，n-i-1）

然后确定位置3的坐标，位置3也可以找规律，发现和位置1的动作轨迹是完全相反的，当位置1向右移动时，位置3向左移动；位置1向下移动时，位置3向上走，所以位置3的坐标是（n-i-1，n-j-1）

最后是位置4的坐标，位置4的轨迹是和位置2的轨迹相反的，所以位置4的坐标也定下来了，直接用n减去2的坐标（n-j-1，i）

```
void rotate(std::vector<std::vector<int>> &matrix)
{
    int n = matrix.size();
    for (int i = 0; i < n / 2; ++i)
    {
        for (int j = i; j < n - i - 1; ++j)
        {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
}
```
